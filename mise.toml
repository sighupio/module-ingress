# Copyright (c) 2017-present SIGHUP s.r.l All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

[tools]
kind = "0.29.0"    
kubectl = "1.33.4" 
kustomize = "5.6.0"
helm = "3.15.0"    
yq = "4.43.1"      
go = "1.23"        
bats = "1.11.0"    
dyff = "1.9.0"    
drone = "1.9.0"
"ubi:google/addlicense" = "v1.1.1"
gh = "2.86.0"

# Development task definitions
[tasks.add-license]
description = "Add license headers to all files"
run = '''
echo "üìÑ Adding license headers..."
addlicense -c "SIGHUP s.r.l" -y "2017-present" -v -l bsd .
echo "‚úÖ License headers added!"
'''

[tasks.validate-manifests]
description = "Validate all manifests can be built"
run = '''
echo "üîç Validating manifest builds..."
kustomize build katalog/cert-manager > /dev/null && echo "  ‚úÖ cert-manager"
kustomize build katalog/dual-nginx > /dev/null && echo "  ‚úÖ dual-nginx"
kustomize build katalog/forecastle > /dev/null && echo "  ‚úÖ forecastle"
kustomize build katalog/nginx > /dev/null && echo "  ‚úÖ nginx"
kustomize build katalog/haproxy/dual > /dev/null && echo "  ‚úÖ haproxy/dual"
echo "‚úÖ All manifests validated!"
'''

[tasks.setup]
description = "Complete development environment setup"
run = '''
echo "üöÄ Setting up development environment..."
mise run add-license
mise run validate-manifests
echo "‚úÖ Development environment ready!"
'''

[tasks.e2e]
description = "Run complete E2E test suite (create cluster, run tests, cleanup)"
run = '''
#!/bin/bash
set -e

echo "üöÄ Starting E2E Test Suite for Module Ingress"
echo "============================================="

# Trap to ensure cleanup on exit (success or failure)
trap 'mise run e2e-cleanup' EXIT

mise run e2e-create
mise run e2e-test

echo "‚úÖ E2E tests completed successfully!"
'''

[tasks.e2e-create]
description = "Create Kind cluster for E2E tests (K8s 1.33)"
run = '''
#!/bin/bash
set -e

echo "üì¶ Creating E2E Test Environment"
echo "================================="

# Configuration
KUBE_VERSION="1.33.0"
export DRONE_BUILD_NUMBER="${DRONE_BUILD_NUMBER:-9999}"
export DRONE_REPO_NAME="${DRONE_REPO_NAME:-module-ingress}"
CLUSTER_NAME="${DRONE_REPO_NAME}-${DRONE_BUILD_NUMBER}-${KUBE_VERSION}"
KUBECONFIG_PATH="$(pwd)/kubeconfig-e2e"

# Check if cluster already exists
if kind get clusters 2>/dev/null | grep -q "^${CLUSTER_NAME}$"; then
  echo "‚ÑπÔ∏è  Cluster ${CLUSTER_NAME} already exists, reusing..."
else
  echo "üì¶ Creating Kind cluster (K8s ${KUBE_VERSION})..."
  ./katalog/tests/kind/generate-template.sh ${KUBE_VERSION}
  kind create cluster --config "./config-${CLUSTER_NAME}.yaml" --name "${CLUSTER_NAME}"
fi

echo "üìã Setting up kubeconfig..."
kind get kubeconfig --name "${CLUSTER_NAME}" > "${KUBECONFIG_PATH}"
export KUBECONFIG="${KUBECONFIG_PATH}"

echo "‚è≥ Waiting for cluster to be ready..."
until kubectl get serviceaccount default > /dev/null 2>&1; do
  echo "   Waiting for control-plane..."
  sleep 2
done

# Source the env file for port info
source "./env-${CLUSTER_NAME}.env"

echo ""
echo "‚úÖ Cluster is ready!"
echo "===================="
echo "KUBECONFIG=${KUBECONFIG_PATH}"
echo "EXTERNAL_PORT=${EXTERNAL_PORT}"
echo "INTERNAL_PORT=${INTERNAL_PORT}"
echo "HAPROXY_EXTERNAL_PORT=${HAPROXY_EXTERNAL_PORT}"
echo "HAPROXY_INTERNAL_PORT=${HAPROXY_INTERNAL_PORT}"
echo ""
echo "To use kubectl: export KUBECONFIG=${KUBECONFIG_PATH}"
echo "To run tests:   mise run e2e-test"
echo "To cleanup:     mise run e2e-cleanup"
'''

[tasks.e2e-test]
description = "Run BATS E2E tests (requires cluster from e2e-create)"
run = '''
#!/bin/bash
set -e

echo "üß™ Running E2E Tests"
echo "===================="

# Configuration
KUBE_VERSION="1.33.0"
export DRONE_BUILD_NUMBER="${DRONE_BUILD_NUMBER:-9999}"
export DRONE_REPO_NAME="${DRONE_REPO_NAME:-module-ingress}"
CLUSTER_NAME="${DRONE_REPO_NAME}-${DRONE_BUILD_NUMBER}-${KUBE_VERSION}"
KUBECONFIG_PATH="$(pwd)/kubeconfig-e2e"
ENV_FILE="./env-${CLUSTER_NAME}.env"

# Verify cluster exists
if ! kind get clusters 2>/dev/null | grep -q "^${CLUSTER_NAME}$"; then
  echo "‚ùå Error: Cluster ${CLUSTER_NAME} does not exist."
  echo "   Run 'mise run e2e-create' first."
  exit 1
fi

# Verify env file exists
if [ ! -f "${ENV_FILE}" ]; then
  echo "‚ùå Error: Environment file ${ENV_FILE} does not exist."
  echo "   Run 'mise run e2e-create' first."
  exit 1
fi

export KUBECONFIG="${KUBECONFIG_PATH}"
source "${ENV_FILE}"

echo "Running BATS tests..."
bats -t ./katalog/tests/tests.bats

echo "‚úÖ Tests completed!"
'''

[tasks.e2e-cleanup]
description = "Cleanup the E2E test cluster and generated files"
run = '''
#!/bin/bash
KUBE_VERSION="1.33.0"
DRONE_BUILD_NUMBER="${DRONE_BUILD_NUMBER:-9999}"
DRONE_REPO_NAME="${DRONE_REPO_NAME:-module-ingress}"
CLUSTER_NAME="${DRONE_REPO_NAME}-${DRONE_BUILD_NUMBER}-${KUBE_VERSION}"

echo "üßπ Cleaning up cluster ${CLUSTER_NAME}..."
kind delete cluster --name "${CLUSTER_NAME}" 2>/dev/null || true
rm -f "$(pwd)/kubeconfig-e2e"
rm -f "config-${CLUSTER_NAME}.yaml"
rm -f "env-${CLUSTER_NAME}.env"
echo "‚úÖ Cleanup complete!"
'''

[tasks.e2e-send-curl]
description = "Send one curl request to each ingress endpoint"
run = '''
#!/bin/bash
echo "üåê Sending requests to ingress endpoints..."
FAILED=0

curl -sf --resolve "nginx-ext.127.0.0.1.nip.io:11112:127.0.0.1" "http://nginx-ext.127.0.0.1.nip.io:11112/nginx-external" > /dev/null && echo "  ‚úÖ Nginx external" || { echo "  ‚ùå Nginx external FAILED"; FAILED=$((FAILED+1)); }
curl -sf --resolve "nginx-int.127.0.0.1.nip.io:12112:127.0.0.1" "http://nginx-int.127.0.0.1.nip.io:12112/nginx-internal" > /dev/null && echo "  ‚úÖ Nginx internal" || { echo "  ‚ùå Nginx internal FAILED"; FAILED=$((FAILED+1)); }
curl -sf --resolve "haproxy-ext.127.0.0.1.nip.io:13112:127.0.0.1" "http://haproxy-ext.127.0.0.1.nip.io:13112/haproxy-external" > /dev/null && echo "  ‚úÖ HAProxy external" || { echo "  ‚ùå HAProxy external FAILED"; FAILED=$((FAILED+1)); }
curl -sf --resolve "haproxy-int.127.0.0.1.nip.io:14112:127.0.0.1" "http://haproxy-int.127.0.0.1.nip.io:14112/haproxy-internal" > /dev/null && echo "  ‚úÖ HAProxy internal" || { echo "  ‚ùå HAProxy internal FAILED"; FAILED=$((FAILED+1)); }

if [ $FAILED -eq 0 ]; then
  echo "‚úÖ All endpoints OK!"
else
  echo "‚ö†Ô∏è  $FAILED endpoint(s) failed"
  exit 1
fi
'''
